text,label
"fix # <number> , adds local variables for command buffer processing <section> a clear and concise description of what the contribution is . - fixes # <number> <section> error - free build <percent> lcov coverage <section> "" const - ness "" of command buffers are maintained . minimized undefined behavior by creating and localizing changes instead of changing const buffers . <section> - os : ubuntu <number> <section> n / a <section> n / a <section> justin figueroa , vantage systems",2
"fix # <number> , convert <code> return codes and variables to <code> <section> - fixes # <number> - suitable <code> return codes converted over to <code> - <code> <code> / <code> variables holding cfe return codes converted to <code> <section> github ci actions all passing successfully . <section> no change to behavior . <code> is more expressive and improves consistency with cfe / cfs . <section> avi weiss <user>",2
mm <code> return codes and variables should be converted to <code> <section> mm has a few return codes ( as well as local <code> / <code> variables which hold <allcaps> cfe </allcaps> return codes ) that can be easily converted over to the <code> typedef . <section> use the more expressive <code> and improve consistency with cfs . <section> avi weiss <user>,2
"fix # <number> , adds eventstring null termination <section> a clear and concise description of what the contribution is . - fixes # <number> <section> * built app * tested lcov * ran passing cert_testbed <sad> code > test <section> null terminated <code> <section> - os : ubuntu <number> <section> followed similar null - terminated character array concatenation in : <url> <section> if included , identify any third party code and provide text file of license <section> - justin figueroa , vantage",2
"fix # <number> , use <code> for ' size ' variables <section> - fixes # <number> - converted the obvious candidates for conversion to <code> ( mostly local variables ) . - updated the related local test variables to <code> as well for consistency . - all variables updated were already unsigned ( <code> <code> and mostly <code> ) . <number> functions had parameters converted to <code> <code> - <code> <code> - <code> <code> - <code> <code> - <code> even if using <code> is unnecessary in some cases ( and wastes some space ) , it is more expressive and more compliant with the relevant coding standards . <section> github ci actions all passing successfully . <section> no change to behavior other than type changes outlined above . <section> avi weiss <user>",2
size variables should use the <code> type <section> most variables representing sizes in mm use <code> there are a few that do not follow this custom and could be transitioned over . <section> <url> <url> <section> all size variables that can use <code> should do so - <code> is more expressive and more consistent with the relevant coding guidelines . <section> avi weiss <user>,2
"mm command handlers cast away const * x ] i reviewed the [ contributing guide <url> . * x] i reviewed the [ <allcaps> readme </allcaps> file <url> to see if the feature is in the major future work . * [x ] i performed a cursory search to see if the feature request is relevant , not redundant , nor in conflict with other tickets . <section> several mm functions cast away const on their command buffer such that they can manipulate it internally . buffers should be copied to a local variable prior to manipulation . examples include : mm_loadmemfromfilecmd mm_dumpmemtofilecmd mm_symtbltofilecmd <section> audit mm and clean up . <section> dan knutsen <allcaps> nasa </allcaps> goddard",0
"fix # <number> , update initializations causing cppcheck failure <section> fixes # <number> note : all are local variables only . in order of the errors reported in the issue report : mm_dump . c in the <code> function : <code> : <code> is assigned a value ( on line <number> ) before any and all of its references , so it can be safely changed from an initialization to a declaration - only at the top of the function . in the <code> function : <code> : <code> is assigned a value ( on line <number> ) before any and all of its references ( and all are covered logically by this assignment on line <number> ) . in the <code> function : <code> : this is a false positive . i have added a <code> comment on the preceding line as part of this pr . mm_load . c in the <code> function : <code> : <code> is only used on line <number> and it is assigned a value on the immediately preceding line of code . in the <code> function : <code> : <code> is assigned a value on line <number> ( and again on line <number> ) which cover logically all of its uses in the function . mm_mem16 . c in the <code> function : <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . <code> : <code> is assigned a value in the <code> statement on line <number> , and is only used once immediately after that inside that <code> block . in the <code> function : <code> : <code> is assigned a value in the <code> statement on line <number> , and is only used in that <code> / <code> block which is all covered by that local assignment on line <number> . this makes the initialization at the top of the function redundant . <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . in the <code> function : <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . <code> : <code> is only used inside the <code> block ( starting on line <number> ) and it is assigned a value there ( on line <number> ) before any and all of its references . mm_mem32 . c in the <code> function : <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . <code> : <code> is assigned a value in the <code> statement on line <number> , and is only used once immediately after that inside that <code> block . in the <code> function : <code> : <code> is assigned a value in the <code> statement on line <number> , and is only used in that <code> / <code> block which is fully covered by that local assignment on line <number> . this makes the initialization at the top of the function redundant . <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . in the <code> function : <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . <code> : <code> is only used inside the <code> block ( starting on line <number> ) and it is assigned a value there ( on line <number> ) before any and all of its references mm_mem8 . c in the <code> function : <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . <code> : <code> is assigned a value in the <code> statement on line <number> , and is only used once immediately after that inside that <code> block . in the <code> function : <code> : <code> is assigned a value in the <code> statement on line <number> , and is only used in that <code> / <code> block which is fully covered by that local assignment on line <number> . this makes the initialization at the top of the function redundant . <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . in the <code> function : <code> : <code> is assigned a value in the init - statement of the <code> loop on line <number> , so the initialization at the top of the function is redundant . mm_utils . c <code> : <code> is assigned a value on line <number> and is only used once on the next line . <section> github ci actions ( incl . build + run , unit tests etc . ) all passing successfully if separate issue <url> is suppressed image <img> the log from the successful build ( with the <allcaps> gcc </allcaps> suppressions that can not be included in this pr ) can be viewed here : <url> <section> no impact on code behavior . cppcheck now passes without error again . <section> avi <user>",2
new <allcaps> gcc </allcaps> warnings causing build failure [ - werror = stringop - overflow <happy> <section> i believe these are newly triggered <allcaps> gcc </allcaps> warnings ( treated as errors ) that are now causing the standard mm build + run workflow to fail . <code> <section> run the build + run github action on the current main branch mm source code . <section> build + run workflow should run without errors . <section> avi <user>,2
"inconsistent event id naming <section> copy of <url> after finding that there were <number> different event ids to indicate the same thing ( invalid message id ) in <url> i scrubbed the other common commands ( e . g . task initialisation [ <allcaps> init </allcaps> ] , <allcaps> noop </allcaps> , reset counters etc . ) and found the same issue there - almost every component / app had their own variation of the event id name for the exact same event . <section> apply consistent event id names to the events which are common to all / most components and apps . <section> invalid message id : <code> <code> <code> <code> <code> <code> <code> <code> <code> initialization : <code> <code> <code> <code> <code> <code> <code> <allcaps> noop </allcaps> : <code> <code> <code> <code> <code> <code> reset counters : <code> <code> <code> <code> <code> <code> <code> <code> <code> <code> <code> etc . <section> avi weiss <user>",2
"fix # <number> , use cfe_fs_initheader ( ) to initialize <allcaps> cfe </allcaps> header * x] i reviewed the [ contributing guide <url> . * x] i signed and emailed the appropriate [ contributor license agreement <url> to <email> and copied <email> . <section> fix # <number> <section> unit testing <section> no impact to behavior <section> - os : ubuntu <number> <section> haven carlson - <allcaps> nasa </allcaps>",2
resolve issues building users guide with ubuntu <number> / doxygen <date> <section> doxygen warnings for <code> <section> resove <section> none <section> none <section> jacob hageman - <allcaps> nasa </allcaps> / <allcaps> gsfc </allcaps>,1
"implicit padding being added to multiple mm commands * x ] i reviewed the [ contributing guide <url> . * x ] i reviewed the [ <allcaps> readme </allcaps> file <url> to see if the feature is in the major future work . * [x ] i performed a cursory search to see if the feature request is relevant , not redundant , nor in conflict with other tickets . <section> some mm commands assume a <number> bit aligned header while others are offset by <number> bits . an example would be the peek vs poke commands . <section> dan knutsen <allcaps> nasa </allcaps> goddard",2
"fix # <number> , updates <allcaps> cla </allcaps> information for apache <number> deletes old mm clas , removes language in contributing . md of app - specific <allcaps> cla </allcaps> , adds link to new clas in pull_request_template <section> a clear and concise description of what the contribution is . - fixes # <number> - fixes <url> <section> visually inspected links in fork and in pr template . <section> all references to clas should be updated to the cfs app <allcaps> cla </allcaps> . <section> google chrome browser <section> none <section> justin figueroa , <allcaps> asrc </allcaps> federal",1
use fixed sizes for memory addresses and offsets in tbl / cmd / tlm <section> same as nasa / cs # <number> . using cpuaddr in tbl / cmd / tlm results in different sized structures ( and possibly different alignment / padding ) . <section> use <code> and <code> <section> none <section> none <section> jacob hageman - <allcaps> nasa </allcaps> / <allcaps> gsfc </allcaps>,2
"update <allcaps> cla </allcaps> information * [ ] i performed a cursory search to see if the feature request is relevant , not redundant , nor in conflict with other tickets . <section> have new clas given the change in <url> with the combined <allcaps> cla </allcaps> , <section> - [ ] update the instructions in each app ' s contributing . md - [ ] delete old <allcaps> cla </allcaps> pdfs - [ ] update pr and issue templates as needed <section> none <section> none <section> gerardo e . cruz - ortiz",1
remove cfe_psp_memset and cfe_psp_memcpy use on addresses in <allcaps> ram </allcaps> <section> should just use memset / memcpy for addresses in <allcaps> ram </allcaps> . the <allcaps> psp </allcaps> functions serve no use in this context . <section> replace with memset / memcpy . <section> none <section> none <section> jacob hageman - <allcaps> nasa </allcaps> / <allcaps> gsfc </allcaps>,2
"mm messages - memory address being truncated to <number> bits on <number> bit machines <section> memory address ' s displayed in messages are ( sometimes ) being truncated to <number> bits on <number> bit machines <section> example from mm_app . c : cfe_evs_sendevent ( mm_sym_lookup_inf_eid , cfe_evs_eventtype_information , "" symbol lookup command : name = ' %s ' addr = 0x % 0 8 x"", cmdptr - > symname , ( unsigned int ) resolvedaddr ) ; <section> dan knutsen <allcaps> nasa </allcaps> goddard",0
"mm_fillmem does not call mm_segmentbreak like read from or write to file <section> mm_fillmem writes memory in a tight loop here with no mm_segmentbreak : <url> both mm_loadmemfromfile and mm_dumpmemtofile do have a mm_segmentbreak ( example ) : <url> mm_fillmem is likely quicker , but should still support a break <section> add mm_segmentbreak <section> could leave as is , but large fill command processing could hog the <allcaps> cpu </allcaps> <section> none <section> jacob hageman - <allcaps> nasa </allcaps> / <allcaps> gsfc </allcaps>",2
"static analysis workflow fails due to strict cppcheck style warnings <section> workflow failure , see <url> <code> <section> fix <section> none <section> none <section> jacob hageman - <allcaps> nasa </allcaps> / <allcaps> gsfc </allcaps>",2
"static analysis issues relative to flight code handful of static analysis issues in the "" red "" identified ( non - style issues ) . need to resolve these . filter : - file : elf - file : ut - file : cfe - file : os - file : cf_ - file : _lab_app . c ! ( significance : style ) should resolve and / or disposition the higher ranked ones at minimum . note license restricts publishing issues . imported from <allcaps> gsfccfs </allcaps> - <number>",0
remove all mentions of <allcaps> asist </allcaps> or <allcaps> itos </allcaps> artifacts from documentation some of our doxygen docs still reference <allcaps> asist </allcaps> or <allcaps> itos </allcaps> artifacts . see cfs_mm repo : fsw / src / mm_msgdefs . h : l28 imported from <allcaps> gsfccfs </allcaps> - <number>,1
apps should use cfe_msg_ptr macro instead of cast or local unwrapping apps typically cast to a cfe_msg_message_t or use * . msg . better to use abstracted cfe_msg_ptr . <allcaps> note </allcaps> - not backwards compatible with caelum so recommend not addressing in draco . imported from <allcaps> gsfccfs </allcaps> - <number>,2
mm should include the status of the <allcaps> eeprom </allcaps> write enable in housekeeping telemetry mm includes commands to enable or disable writing to <allcaps> eeprom </allcaps> . that setting cannot currently be verified in telemetry . the status of the write enable for each <allcaps> eeprom </allcaps> bank should be added to the housekeeping packet . imported from <allcaps> gsfccfs </allcaps> - <number>,2
"change order of size checks for optimization in mm_verifyloadwidparams , it is more efficient to check sizeinbytes before calling cfe_psp_memvalidaterange . this same optimization would be applicable in other functions . imported from <allcaps> gsfccfs </allcaps> - <number>",2
perf counter in mm_segmentbreak may be unnecessary the performance marker only wraps a task delay . imported from <allcaps> gsfccfs </allcaps> - <number>,2
"mm clarify names of constants mm configuration parameters for sizes often do not include the word <allcaps> size </allcaps> , making their purpose a little less clear . imported from <allcaps> gsfccfs </allcaps> - <number>",2
function names mm_resethk and mm_writememwid are misleading imported from <allcaps> gsfccfs </allcaps> - <number>,2
make mm memtype into an enum imported from <allcaps> gsfccfs </allcaps> - <number>,2
"mm_dumpineventcmd wastes event characters in mm_dumpineventcmd , including the "" 0x "" and trailing space on the hex digits unnecessarily limits how much can actually be dumped in the event . imported from <allcaps> gsfccfs </allcaps> - <number>",2
"mm investigate use of static variables in mm_dumpineventcmd , eventstring is declared as static to keep it off the stack . need to investigate whether this is necessary . imported from <allcaps> gsfccfs </allcaps> - <number>",2
generally better to initialize return code to false imported from <allcaps> gsfccfs </allcaps> - <number>,2
"in mm_dumpmemtofilecmd , would be faster to checksum while writing imported from <allcaps> gsfccfs </allcaps> - <number>",2
in mm_dumpmemtofile command could use cfe_fs_initheader imported from <allcaps> gsfccfs </allcaps> - <number>,2
investigate whether eeprom and symtable handing belongs in mm some discussion needed in the future to reevaluate whether eeprom and symbol table handling belongs in mm since not every platform has them . imported from <allcaps> gsfccfs </allcaps> - <number>,2
"mm intlock removed , no longer implements "" write with interrupts disabled "" requirement mm2003 historical - ( note the lock / unlock have been removed , see comments ) : memory manager uses os_intlock ( ) and os_intunlock ( ) . that ' s the only place any of the os_int * functions are used in the <allcaps> gsfc </allcaps> apps . these functions will likely be deprecated in the next <allcaps> osal </allcaps> release . i am guessing it does this with the intent of loading the mem block "" atomically "" with the hope of preventing another task from writing to it while this happens ? intlock / unlock has always been a no - op on <allcaps> posix </allcaps> , and furthermore even on platforms where it does something , it will not achieve that exclusivity effect on multi - core cpus , as it only locks the interrupts on the core which calls it , and other cores continue to run anyway , interrupt or not . probably worth re - evaulating what mm is trying to achieve with the intlock . <repeated> might be able to simply take it out with no loss of function . <number> - os_intloc and os_intunlock were removed as part of <allcaps> gsfccfs </allcaps> - <number> . although now requirement <allcaps> gsfccfs </allcaps> - <number> is not being met . imported from <allcaps> gsfccfs </allcaps> - <number>",0
"mm unclear app configuration assumptions stakeholder : discovered and added comments to the config file that some app configuration values have assumptions on modulo - <number> or modulo - <number> sizes . for example , these <number> and <number> - bit dump routines would fail if these config <hashtag> defines </hashtag> are not set with the appropriate values . imported from <allcaps> gsfccfs </allcaps> - <number>",2
