text,label
update ci pipeline to use github actions the existing travis ci pipeline is out of date and no longer functional . we should migrate to using github actions to get the pipeline working again .,0
"support for multiple user - defined commands the current way the <allcaps> eci </allcaps> handles commands by using the eci_cmd_mid does not support any more than <number> custom command . this problem has to do with the limitation that when declaring the buffer / object to store the received command data , the <allcaps> eci </allcaps> can not determine which object to use by only using the eci_cmd_mid . in particular , the problem can be isolated to the behavior for non - eci_cmd_mid values in the default of the switch statement processing commands <url> <code> rcv_msg ` function , the same checks for the length and updates to the cmderrorcounter still happen so no other changes should be needed .",0
"broken links to example code in documentation at some point the links to the example code have been broken and now appear empty . this problem , on first glance , only seems to affect the <code> file referenced for the creating eci interface <url> but we should probably check to make sure this did not affect anything else .",0
<number> fix <allcaps> cds </allcaps> implementation * update name of <allcaps> cds </allcaps> table in <allcaps> eci </allcaps> code ( expected to be provided by eci_interface . h ) * add <allcaps> cds </allcaps> table to example as test case * fix undeclared status variable in <allcaps> cds </allcaps> handling * update spec to reflect new <allcaps> cds </allcaps> variable name,0
"fix <code> undefined the <allcaps> sil </allcaps> is currently in the process of implementing the <allcaps> eci </allcaps> ' s <allcaps> cds </allcaps> interface and currently cannot compile with <allcaps> eci </allcaps> because it does not define <code> , which is the structure <allcaps> eci </allcaps> expects to contain the definition of the <allcaps> cds </allcaps> elements . it defines that structure as <code> . normally the <allcaps> sil </allcaps> would need to align with <allcaps> eci </allcaps> definitions , however , the <allcaps> sil </allcaps> ' s name is better ( does not look like a macro , is clear that its a table ) , and so in this case the <allcaps> eci </allcaps> should be updated . i do not believe there are currently any test cases using <allcaps> cds </allcaps> in the <allcaps> eci </allcaps> repo , so this update should only require modification to the <allcaps> eci </allcaps> source code .",0
"fix <code> undefined <code> includes all <allcaps> eci </allcaps> header files after including <code> because some defines in <code> influence the code implemented in <code> . this is intended , however , <code> used <code> ( defined in <code> ) if commands are defined , which causes compilation to fail . need to update include order . also need to ensure an test suite includes and example of an app with a command to catch this in the future .",0
"add check for command <allcaps> apid </allcaps> when command queue defined the segfault in issue # <number> was caused by specifying a command <allcaps> mid </allcaps> with a message not defined as a command ( and which thus had no queue defined for it ) . the <allcaps> eci </allcaps> code blindly attempted to utilize the queue which did not exist , causing the segfault . during the course of resolving that issue it was determined that a check can be done here <url> to confirm the that there ' s a queue allocated if the <allcaps> mid </allcaps> indicates the message is a command . that check would look something like if <code> , issue an error event message warning the user about a misconfiguration , and either * skip the configuration of the queue for that message ( if we can establish that the app will still work without it ) * exit the app , if its going to be too broken to function work needs to be done to determine the correct course of action and implement this check .",2
"add support for custom <allcaps> ccsds </allcaps> commands through the <allcaps> eci </allcaps> header it ' s been a commonly requested internal feature to add support for custom commands as part of the <allcaps> eci </allcaps> . currently , the only commands supported are housekeeping and noop but these are standard across apps . this feature should not impact the performance of any other parts of the <allcaps> eci </allcaps> and can be included as part of the eci_interface header file . the structure exposed should look like : <code> where function code is a <number> byte value to identify the command and the function pointer is a c style function pointer to the function to execute once the command is received . to reduce the boiler plate code needed to be written , we also include an extra field containing the structure to fill with command information . more information on the <allcaps> ccsds </allcaps> packet protocol can be found here <url> under section <number> . <number> : "" packet secondary header "" . the <allcaps> cfs </allcaps> uses only the ancillary field of the secondary packet header and the relevant portion for this issue will be 0x 7 f00 > > <number> defined as the function code of the command message .",2
"add a tutorial on how to build the docs locally even though the new documentation automatically gets pushed into github pages , we still need instructions to build locally .",1
alter the sample app compiler flag to satisfy the cfs - groundsystem the latest commit of the cfs - groundsystem includes glibc specific features specifically the inclusion of the <code> . the addrinfo struct definition is only exposed in gcc when passed a gnu compliant standard ( the current test cmake definition uses <code> ) . more information on the topic of c standard compliance vs the <allcaps> gnu </allcaps> libraries can be found on this stack overflow post : <url>,0
fix the spelling error in to_lab for testing a recent commit to the master branch of to_lab fixed a spelling mistake <url> which needs to be reflected in the to_lab sub table header in the testing files .,0
no examples of using <allcaps> eci </allcaps> for <allcaps> cds </allcaps> management none of the examples provided give any insight on how to manage the <allcaps> cds </allcaps> using the internal <allcaps> eci </allcaps> mechanisms .,2
"add checks to make sure each required macro is set in addition to the documentation mentioning what macros need to be set in the interface file for an app , there should be a compile time warning alerting the user to undefined values . it might also be prudent to add validity checks against the entered values ( for example when a bad <allcaps> mid </allcaps> was provided or a name exceeds a max value for the cfe ) .",2
"add an explanation of the message id ' s used by <allcaps> eci </allcaps> since <allcaps> eci </allcaps> expects certain macro ' s to be defined for the system to work , these macro names should be added to the documentation . currently , there is a reference that needs to link to this page in the doxy branch .",1
"update the documentation for each of the <allcaps> eci </allcaps> structures even though everything was converted into auto - doc comments for doxygen , the content has been lacking . specifically , we need to document the members of the structures provided for use in the <code> file since it ' s more user facing . for maintainability , each structure should have a good explanation of it ' s intended use and a brief explanation of it ' s members .",1
"provide a tutorial describing what ' s needed to build an app with <allcaps> eci </allcaps> the previous approach of directing people to the automated build system leaves some holes when trying to explain how to integrate an app with <allcaps> eci </allcaps> . to combat this , we should provide an explanation of how to build an <allcaps> eci </allcaps> app in both the cfe make and cmake build systems . information for building a <number> <allcaps> eci </allcaps> app can be found here <url> but there is not any explanation of how to build with cmake .",1
provide a walk through of the main components of the <allcaps> eci </allcaps> we have had a large amount of questions asking for an introduction to how to configure the <allcaps> eci </allcaps> . this should be part of a larger scale effort to document <allcaps> eci </allcaps> up to a standard of basic usability .,1
"build and run existing <allcaps> eci </allcaps> unit tests under <allcaps> cfe </allcaps> <number> since the cfe <number> removed the for_build directory in it ' s cmake build system , we are kind of lost on how to add unit tests for the cfs <number> apps using ut assert . effort needs to be made to figure out what unit test looks like for <allcaps> eci </allcaps> <number> and document it accordingly .",2
"make the sgp4 example more noisy although this seems like a strange issue , it ' s not very obvious to a user whether or not the example sgp4 app works . it would be a nice addition to sgp4 to add some sort of periodic event message to show that the app has initialized and the main loop is executing . edit : the simple app could benefit from this as well .",2
"add ci tests to start <allcaps> cfs </allcaps> and verify no errors in many cases , verifying that code compiles is not sufficient to ensure that it runs as expected . as an extra level of verification , it would be nice to add some ci tests to actually startup the <allcaps> cfs </allcaps> system and verify that the intended apps start and no initialization errors occur . this would be good to have for both <allcaps> cfe </allcaps> <number> and <number> on the master and cfe - <number> branches respectively .",2
"improve cmake function naming / documentation for cfe <number> branch some new users are reporting that its hard to figure out how to build a <allcaps> cfs </allcaps> app with <allcaps> eci </allcaps> ( example # <number> ) . i think this can be partially addressed by pointing them at the ci pipeline as a "" recipe "" , but i think it would be helpful to add some better breadcrumbs for them to follow . as a couple examples , i ' d suggest perhaps : * renaming <code> to <code> or something similar , to reflect that there are functions in there for doing more than just setting up cfe ( sets up <allcaps> cfs </allcaps> system , also some helper functions for integrating <allcaps> eci </allcaps> apps , etc ) . * add docstrings for each function in that file explaining the result of each and perhaps at what point in the integration process its useful . * ensure that the function names reflect their purpose . for example , i think <code> might be more aptly called <code> or <code> ( though that ' s a little verbose ) . <code> i think performs multiple operations ( integrates to / sch / ci files , install eci source , etc ) but from the name i ' d think it only puts the <allcaps> eci </allcaps> source files into the <allcaps> cfs </allcaps> tree . * ensure that functions output messages to track their progress , which can also help document the functions . let me know if this makes sense and we can discuss any specific changes here as well .",2
"fixed the test builds for cfe <number> this commit makes multiple changes to return the tests to a working state . for whatever reason , the simple app never worked when ran in a cfs context even though it built . close # <number>",0
"suggest enhanced version information reporting ( at init and noop ) at build put the response from <code> ( similar to version . cmake in cfe / cmake ) into a define and report by the code if defined in addition to the manual version number . can do it at build - d_enhanced_v_name_ = response from git , or generate a header file on the fly and poke in the <hashtag> define </hashtag> , and include from the code . cfs app guide will eventually say something like this , it ' s the direction we are going with version reporting to eliminate all the manual changes to the version header ( only required at release with this update ) , or the confusion it causes when it ' s not updated . since before every merge to master really was a new version but not tracked well .",2
"<allcaps> eci </allcaps> strip headers from incoming packets for prior uses of <allcaps> eci </allcaps> , keeping the header of ingested packets was desirable because it contained information used in the processing of the packet . for some applications that header is unneeded or burdensome to the external code , which has to allocate space for it in its data structures . to maintain compatibility its likely that keeping the header will continue to be the default <allcaps> eci </allcaps> behavior , but adding the ability for the <allcaps> eci </allcaps> to strip the header off an incoming packet and a configuration setting so that the user could enable this functionality might be a good improvement . for the envisioned use case , a global setting ( applying to all incoming packets ) is sufficient but not sure if there are use - cases where the ability to set this per - packet would be needed .",2
"<allcaps> eci </allcaps> not updating outgoing packet headers properly in past usage , the external code allocated space for the <allcaps> ccsds </allcaps> header in the output messages , but expected the <allcaps> eci </allcaps> to manage the header ( which is generally out - of - scope for the external code ) . this was implemented by having the <allcaps> eci </allcaps> initialize the header at startup ( using cfe_sb_initmsg ) and then filling the messageid ( via cfe_sb_setmsgid ) , packet length ( via cfe_sb_settotalmsglength ) , and timestamp ( via cfe_sb_timestampmsg ) after each step function . this implementation works so long as the external code does not modify the header . it was discovered that if the external code overwrote the secondary header flag to indicate no secondary header , cfe_sb_timestampmsg , which checks that flag , did not update the time as intended . to remedy this situation and better define the intent of the external code , i intend to update the <allcaps> eci </allcaps> such that it overwrite the entire header ( using cfe_sb_initmsg ) after the execution of the step function and then update the timestamp ( using cfe_sb_timestampmsg ) , which ensures a correct header regardless of what the step function may have done during execution . the external code may disable this functionality by defining <code> , in which case the external code takes full responsibility for managing the header ( including setting the messageid , packet length , and timestamps or checksum ) . this change preserves the current output message definition , but does not allow packet - by - packet control of this behavior . that could be investigated if that ' s a desired feature .",0
